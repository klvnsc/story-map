#!/usr/bin/env ts-node

import { Command } from 'commander';
import * as fs from 'fs';
import * as path from 'path';
import { 
  loadCollectionsManifest, 
  getCollectionInfoFromManifest, 
  getAllCollectionNumbersFromManifest,
  getCollectionsNeedingFetch,
  getHighlightIdFromLegacyCsv
} from './utils/manifest-collection-mapping';
import { fetchCollectionHtml } from './steps/step1-fetch-html';
import { parseCollectionHtml } from './steps/step2-parse-html';

// Load environment variables
require('dotenv').config({ path: '.env.local' });

const program = new Command();

program
  .name('regenerate-collections')
  .description('Regenerate all collection CSV/HTML files using the new chronological numbering from manifest')
  .version('1.0.0');

program
  .command('all')
  .description('Regenerate all collections using manifest mapping')
  .option('--dry-run', 'Show what would be done without executing')
  .option('--rate-limit <ms>', 'Rate limit between API calls (ms)', '2000')
  .action(async (options) => {
    try {
      console.log('üîÑ Regenerating all collections from manifest...\n');
      
      const manifest = loadCollectionsManifest();
      const allCollections = getAllCollectionNumbersFromManifest();
      
      console.log(`üìã Manifest loaded: ${manifest.metadata.total_collections} collections`);
      console.log(`üìÖ Created: ${manifest.metadata.created}`);
      console.log(`üìä Collections to process: ${allCollections.length}\n`);
      
      if (options.dryRun) {
        console.log('üîç DRY RUN - Showing what would be done:\n');
      }
      
      let successCount = 0;
      let skipCount = 0;
      let errorCount = 0;
      const rateLimitMs = parseInt(options.rateLimit);
      
      for (const collectionNumber of allCollections) {
        try {
          const collectionInfo = getCollectionInfoFromManifest(collectionNumber);
          
          console.log(`\nüìÅ Collection ${collectionNumber}: ${collectionInfo.name}`);
          console.log(`   Phase: ${collectionInfo.expeditionPhase}`);
          console.log(`   Original Index: ${collectionInfo.originalIndex || 'New'}`);
          
          // Determine Instagram ID source
          let instagramId = collectionInfo.highlightId;
          
          if (!instagramId && collectionInfo.originalIndex) {
            // Try to get from legacy CSV
            try {
              instagramId = getHighlightIdFromLegacyCsv(collectionInfo.originalIndex);
              console.log(`   Instagram ID: ${instagramId} (from legacy CSV)`);
            } catch (error) {
              console.log(`   ‚ùå No Instagram ID found for original index ${collectionInfo.originalIndex}`);
              errorCount++;
              continue;
            }
          } else if (instagramId) {
            console.log(`   Instagram ID: ${instagramId} (from manifest)`);
          } else {
            console.log(`   ‚ö†Ô∏è  No Instagram ID available - skipping`);
            skipCount++;
            continue;
          }
          
          const csvPath = path.join(process.cwd(), 'data-story-collection', `${collectionNumber}.csv`);
          const htmlPath = path.join(process.cwd(), 'data-story-collection', `${collectionNumber}.html`);
          
          if (options.dryRun) {
            console.log(`   Would create: ${csvPath}`);
            console.log(`   Would create: ${htmlPath}`);
            successCount++;
            continue;
          }
          
          // Step 1: Fetch HTML
          console.log(`   üåê Fetching HTML data...`);
          await fetchCollectionHtml(collectionNumber, instagramId, {
            outputDir: path.join(process.cwd(), 'data-story-collection'),
            rateLimitMs
          });
          
          // Step 2: Parse HTML to CSV
          console.log(`   üìÑ Parsing HTML to CSV...`);
          await parseCollectionHtml(collectionNumber, {
            inputDir: path.join(process.cwd(), 'data-story-collection'),
            outputDir: path.join(process.cwd(), 'data-story-collection')
          });
          
          console.log(`   ‚úÖ Generated ${collectionNumber}.csv and ${collectionNumber}.html`);
          successCount++;
          
          // Rate limiting
          if (rateLimitMs > 0) {
            console.log(`   ‚è≥ Rate limiting: ${rateLimitMs}ms`);
            await new Promise(resolve => setTimeout(resolve, rateLimitMs));
          }
          
        } catch (error) {
          console.error(`   ‚ùå Error processing collection ${collectionNumber}:`, error.message);
          errorCount++;
        }
      }
      
      // Summary
      console.log('\nüéØ Regeneration Summary:');
      console.log(`   ‚úÖ Success: ${successCount}`);
      console.log(`   ‚ö†Ô∏è  Skipped: ${skipCount}`);  
      console.log(`   ‚ùå Errors: ${errorCount}`);
      console.log(`   üìä Total: ${allCollections.length}`);
      
      if (options.dryRun) {
        console.log('\nüí° To execute, run without --dry-run flag');
      }
      
    } catch (error) {
      console.error('‚ùå Failed to regenerate collections:', error.message);
      process.exit(1);
    }
  });

program
  .command('missing')
  .description('Only regenerate collections that are missing CSV files')
  .option('--dry-run', 'Show what would be done without executing')  
  .option('--rate-limit <ms>', 'Rate limit between API calls (ms)', '2000')
  .action(async (options) => {
    try {
      console.log('üîç Finding collections that need CSV/HTML files...\n');
      
      const missingCollections = getCollectionsNeedingFetch();
      
      if (missingCollections.length === 0) {
        console.log('‚úÖ All collections already have CSV files - nothing to do!');
        return;
      }
      
      console.log(`üìã Collections needing files: ${missingCollections.join(', ')}\n`);
      
      if (options.dryRun) {
        console.log('üîç DRY RUN - Would process these collections:');
        missingCollections.forEach(num => {
          const info = getCollectionInfoFromManifest(num);
          console.log(`   ${num}: ${info.name} (${info.expeditionPhase})`);
        });
        return;
      }
      
      // Process missing collections
      let successCount = 0;
      let errorCount = 0;
      const rateLimitMs = parseInt(options.rateLimit);
      
      for (const collectionNumber of missingCollections) {
        try {
          const collectionInfo = getCollectionInfoFromManifest(collectionNumber);
          
          console.log(`\nüìÅ Collection ${collectionNumber}: ${collectionInfo.name}`);
          
          let instagramId = collectionInfo.highlightId;
          
          if (!instagramId && collectionInfo.originalIndex) {
            instagramId = getHighlightIdFromLegacyCsv(collectionInfo.originalIndex);
          }
          
          if (!instagramId) {
            console.log(`   ‚ùå No Instagram ID available - skipping`);
            errorCount++;
            continue;
          }
          
          console.log(`   üåê Fetching and parsing...`);
          
          // Fetch and parse
          await fetchCollectionHtml(collectionNumber, instagramId, {
            outputDir: path.join(process.cwd(), 'data-story-collection'),
            rateLimitMs
          });
          
          await parseCollectionHtml(collectionNumber, {
            inputDir: path.join(process.cwd(), 'data-story-collection'),
            outputDir: path.join(process.cwd(), 'data-story-collection')
          });
          
          console.log(`   ‚úÖ Success`);
          successCount++;
          
          if (rateLimitMs > 0) {
            await new Promise(resolve => setTimeout(resolve, rateLimitMs));
          }
          
        } catch (error) {
          console.error(`   ‚ùå Error:`, error.message);
          errorCount++;
        }
      }
      
      console.log('\nüéØ Results:');
      console.log(`   ‚úÖ Success: ${successCount}`);
      console.log(`   ‚ùå Errors: ${errorCount}`);
      
    } catch (error) {
      console.error('‚ùå Failed:', error.message);
      process.exit(1);
    }
  });

// Show help by default
if (process.argv.length <= 2) {
  program.help();
}

program.parse();