-- Database Date Duplicate Analysis Report
-- Run this in your Supabase SQL editor to identify date conflicts and duplicates
-- Generated by Claude Code for Story Map Project

-- ============================================================================
-- PART 1: story_collections Table Date Analysis
-- ============================================================================

-- Check for duplicate estimated_date values in story_collections
SELECT 
  estimated_date,
  COUNT(*) as collection_count,
  STRING_AGG(name, ', ' ORDER BY name) as collections_with_same_date
FROM story_collections 
WHERE estimated_date IS NOT NULL
GROUP BY estimated_date
HAVING COUNT(*) > 1
ORDER BY estimated_date;

-- Check date range overlaps in story_collections (if schema updates applied)
SELECT 
  sc1.name as collection1,
  sc1.estimated_date_range_start as start1,
  sc1.estimated_date_range_end as end1,
  sc2.name as collection2,
  sc2.estimated_date_range_start as start2,
  sc2.estimated_date_range_end as end2
FROM story_collections sc1
JOIN story_collections sc2 ON sc1.id != sc2.id
WHERE sc1.estimated_date_range_start IS NOT NULL 
  AND sc1.estimated_date_range_end IS NOT NULL
  AND sc2.estimated_date_range_start IS NOT NULL 
  AND sc2.estimated_date_range_end IS NOT NULL
  AND (
    (sc1.estimated_date_range_start <= sc2.estimated_date_range_end 
     AND sc1.estimated_date_range_end >= sc2.estimated_date_range_start)
  )
ORDER BY sc1.estimated_date_range_start, sc2.estimated_date_range_start;

-- ============================================================================
-- PART 2: stories Table Date Analysis  
-- ============================================================================

-- Check for stories with multiple date values that conflict
SELECT 
  id,
  estimated_date,
  user_assigned_date,
  collection_default_date,
  estimated_date_range_start,
  estimated_date_range_end,
  CASE 
    WHEN estimated_date IS NOT NULL AND user_assigned_date IS NOT NULL 
         AND estimated_date::date != user_assigned_date::date THEN 'estimated_vs_user_conflict'
    WHEN estimated_date IS NOT NULL AND collection_default_date IS NOT NULL 
         AND estimated_date::date != collection_default_date::date THEN 'estimated_vs_collection_conflict'
    WHEN user_assigned_date IS NOT NULL AND collection_default_date IS NOT NULL 
         AND user_assigned_date::date != collection_default_date::date THEN 'user_vs_collection_conflict'
    ELSE 'no_conflict'
  END as conflict_type
FROM stories 
WHERE (estimated_date IS NOT NULL AND user_assigned_date IS NOT NULL AND estimated_date::date != user_assigned_date::date)
   OR (estimated_date IS NOT NULL AND collection_default_date IS NOT NULL AND estimated_date::date != collection_default_date::date)
   OR (user_assigned_date IS NOT NULL AND collection_default_date IS NOT NULL AND user_assigned_date::date != collection_default_date::date);

-- Count stories by date field availability
SELECT 
  'estimated_date' as field_name,
  COUNT(CASE WHEN estimated_date IS NOT NULL THEN 1 END) as has_value_count,
  COUNT(CASE WHEN estimated_date IS NULL THEN 1 END) as null_count,
  ROUND(COUNT(CASE WHEN estimated_date IS NOT NULL THEN 1 END) * 100.0 / COUNT(*), 2) as percentage_filled
FROM stories

UNION ALL

SELECT 
  'user_assigned_date' as field_name,
  COUNT(CASE WHEN user_assigned_date IS NOT NULL THEN 1 END) as has_value_count,
  COUNT(CASE WHEN user_assigned_date IS NULL THEN 1 END) as null_count,
  ROUND(COUNT(CASE WHEN user_assigned_date IS NOT NULL THEN 1 END) * 100.0 / COUNT(*), 2) as percentage_filled
FROM stories

UNION ALL

SELECT 
  'collection_default_date' as field_name,
  COUNT(CASE WHEN collection_default_date IS NOT NULL THEN 1 END) as has_value_count,
  COUNT(CASE WHEN collection_default_date IS NULL THEN 1 END) as null_count,
  ROUND(COUNT(CASE WHEN collection_default_date IS NOT NULL THEN 1 END) * 100.0 / COUNT(*), 2) as percentage_filled
FROM stories;

-- ============================================================================
-- PART 3: gps_waypoints Table Date Analysis
-- ============================================================================

-- Check for potential GPS waypoint clustering issues (same exact timestamp)
SELECT 
  recorded_at,
  COUNT(*) as waypoint_count,
  COUNT(DISTINCT latitude) as unique_latitudes,
  COUNT(DISTINCT longitude) as unique_longitudes
FROM gps_waypoints 
GROUP BY recorded_at
HAVING COUNT(*) > 5  -- Flag clusters of more than 5 waypoints at exact same time
ORDER BY waypoint_count DESC;

-- Check GPS date range coverage
SELECT 
  expedition_phase,
  MIN(recorded_at) as earliest_waypoint,
  MAX(recorded_at) as latest_waypoint,
  COUNT(*) as waypoint_count,
  COUNT(DISTINCT recorded_at::date) as unique_days
FROM gps_waypoints 
WHERE expedition_phase IS NOT NULL
GROUP BY expedition_phase
ORDER BY earliest_waypoint;

-- ============================================================================
-- PART 4: Cross-Table Date Correlation Analysis
-- ============================================================================

-- Compare collection estimated dates with GPS waypoint date ranges
SELECT 
  sc.name as collection_name,
  sc.expedition_phase,
  sc.estimated_date as collection_estimated_date,
  gps_stats.earliest_gps,
  gps_stats.latest_gps,
  gps_stats.waypoint_count,
  CASE 
    WHEN sc.estimated_date IS NULL THEN 'no_collection_date'
    WHEN gps_stats.earliest_gps IS NULL THEN 'no_gps_data'
    WHEN sc.estimated_date < gps_stats.earliest_gps::date THEN 'collection_before_gps'
    WHEN sc.estimated_date > gps_stats.latest_gps::date THEN 'collection_after_gps'
    ELSE 'collection_within_gps_range'
  END as date_correlation_status
FROM story_collections sc
LEFT JOIN (
  SELECT 
    expedition_phase,
    MIN(recorded_at) as earliest_gps,
    MAX(recorded_at) as latest_gps,
    COUNT(*) as waypoint_count
  FROM gps_waypoints 
  WHERE expedition_phase IS NOT NULL
  GROUP BY expedition_phase
) gps_stats ON sc.expedition_phase = gps_stats.expedition_phase
ORDER BY sc.estimated_date;

-- ============================================================================
-- PART 5: Collection Number System Analysis
-- ============================================================================

-- Check for missing or duplicate collection numbers/indexes
SELECT 
  collection_index,
  COUNT(*) as collection_count,
  STRING_AGG(name, ', ' ORDER BY name) as collections_with_same_index
FROM story_collections 
WHERE collection_index IS NOT NULL
GROUP BY collection_index
HAVING COUNT(*) > 1
ORDER BY collection_index;

-- Identify gaps in collection numbering sequence
WITH expected_numbers AS (
  SELECT generate_series(1, 61) as expected_index
),
actual_numbers AS (
  SELECT DISTINCT collection_index as actual_index 
  FROM story_collections 
  WHERE collection_index IS NOT NULL
)
SELECT 
  en.expected_index as missing_collection_number
FROM expected_numbers en
LEFT JOIN actual_numbers an ON en.expected_index = an.actual_index
WHERE an.actual_index IS NULL
ORDER BY en.expected_index;

-- ============================================================================
-- PART 6: Data Quality Summary Report
-- ============================================================================

-- Overall data quality summary
SELECT 
  'story_collections' as table_name,
  COUNT(*) as total_records,
  COUNT(CASE WHEN estimated_date IS NOT NULL THEN 1 END) as records_with_dates,
  COUNT(CASE WHEN expedition_phase IS NOT NULL THEN 1 END) as records_with_phase,
  COUNT(CASE WHEN is_expedition_scope = true THEN 1 END) as expedition_scope_records,
  COUNT(CASE WHEN is_expedition_scope = false THEN 1 END) as excluded_records
FROM story_collections

UNION ALL

SELECT 
  'stories' as table_name,
  COUNT(*) as total_records,
  COUNT(CASE WHEN estimated_date IS NOT NULL OR user_assigned_date IS NOT NULL OR collection_default_date IS NOT NULL THEN 1 END) as records_with_dates,
  COUNT(CASE WHEN latitude IS NOT NULL AND longitude IS NOT NULL THEN 1 END) as records_with_location,
  COUNT(CASE WHEN tag_source = 'excluded' THEN 1 END) as excluded_records,
  NULL as additional_metric
FROM stories

UNION ALL

SELECT 
  'gps_waypoints' as table_name,
  COUNT(*) as total_records,
  COUNT(CASE WHEN recorded_at IS NOT NULL THEN 1 END) as records_with_dates,
  COUNT(CASE WHEN expedition_phase IS NOT NULL THEN 1 END) as records_with_phase,
  NULL as expedition_scope_records,
  NULL as excluded_records
FROM gps_waypoints;

-- ============================================================================
-- PART 7: Recommendations for Data Cleanup
-- ============================================================================

-- Generate cleanup recommendations based on analysis
WITH date_conflicts AS (
  SELECT COUNT(*) as conflict_count
  FROM stories 
  WHERE (estimated_date IS NOT NULL AND user_assigned_date IS NOT NULL AND estimated_date::date != user_assigned_date::date)
     OR (estimated_date IS NOT NULL AND collection_default_date IS NOT NULL AND estimated_date::date != collection_default_date::date)
     OR (user_assigned_date IS NOT NULL AND collection_default_date IS NOT NULL AND user_assigned_date::date != collection_default_date::date)
),
duplicate_collection_dates AS (
  SELECT COUNT(*) as duplicate_count
  FROM (
    SELECT estimated_date
    FROM story_collections 
    WHERE estimated_date IS NOT NULL
    GROUP BY estimated_date
    HAVING COUNT(*) > 1
  ) dupes
)
SELECT 
  'RECOMMENDATIONS' as analysis_type,
  CASE 
    WHEN dc.conflict_count > 0 THEN 'URGENT: Resolve ' || dc.conflict_count || ' date conflicts in stories table'
    ELSE 'No critical date conflicts found in stories table'
  END as date_conflict_recommendation,
  CASE 
    WHEN dcd.duplicate_count > 0 THEN 'WARNING: ' || dcd.duplicate_count || ' duplicate dates in collections - consider date range approach'
    ELSE 'No duplicate collection dates found'
  END as duplicate_date_recommendation
FROM date_conflicts dc, duplicate_collection_dates dcd;